% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stdbscan.R
\name{stdbscan}
\alias{stdbscan}
\title{calc ST-DBSCAN clustering.}
\usage{
stdbscan(
  x,
  time = NULL,
  eps1 = double(),
  eps2 = double(),
  minPts = integer(),
  vals = list(list(D = double(), delta_eps = double())),
  metric = c("euclidean", "geo"),
  neighbortype = c("spatial", "random"),
  dbscantype = c("grid", "default")
)
}
\arguments{
\item{x}{matrix\link{, c(x, y)}, data.frame(x, y), sf, sfc を指定します。
matrixの場合は、2列の行列を指定し、1列目にはx軸 (long), 2列目にはy軸 (lat) の情報を指定します。
data.frameの場合は、\code{x} 列にx軸, \code{y} 列にy軸の情報を指定します。
sf及びsfcの場合はそのまま指定できますが、sfデータにgeometryのみが利用されます。
neighbortype = "random" の場合、'x' に 時間情報を含めることができます。その場合、列名は 'time' としてください。}

\item{time}{時間軸情報をベクトルで指定します。数値、POSIXct等、任意のデータ型を指定します。}

\item{eps1}{空間的な距離の閾値を指定します。これは \code{dbscan::dbscan} 関数で指定する \code{eps} 引数の値に該当します。}

\item{eps2}{時間的な距離の閾値をしています。
\code{time} 引数を数値で指定した場合は、隣接時間となる値を数値で指定し、 \code{POSIXct} 形式で指定した場合は秒 (sec) で指定します。}

\item{minPts}{クラスターと認識する最低の隣接点数を整数で指定します。}

\item{vals}{空間・時間軸に該当するデータを \code{list} 形式でしています。また、このデータのクラスターを判別するための閾値 (Δeps) も指定します。
データは次の例のように複数指定することができます
list(list(D = vector(), delta_eps = double()), list(D = vector(), delta_eps = double()), ...)}

\item{metric}{空間的距離を算出するための方法を指定します。
\itemize{
\item "euclidean": ユークリッド距離 (\code{sqrt((x1 - x1) ^ 2 + (y1 - y1) ^ 2 )}) で距離が計算されます。
\item "geo": 地理空間上の座標 (long, lat) に基づき地点間の距離が計算されます。計算には `spdep::dnearneigh' が利用されます。
}}

\item{neighbortype}{隣接点が空間的に同一か、完全にランダムな配置であるか指定します。
\itemize{
\item "spatial": netCDFデータや定点データのように、位置が時間に応じて変わらないデータを使用する場合に指定します。
\item "random": 地震発生源のような、時間と空間上でランダムなデータを利用する場合に指定します。
}}

\item{dbscantype}{クラスターの判定の際、netCDF形式で配布されている気象データのようなグリッドデータでは、常に一定数の隣接点が存在します。
このような場合、ST-DBSCANのもともとの計算アルゴリズムでは必ずクラスターが生成されるため、意図しない計算結果となることが想定されます。
\code{dbscantype} 引数では、"default" を指定すると従来のアルゴリズムを踏襲し、"grid" を指定すると隣接点と中心点との値差がΔepsとなる隣接点を抽出し、その数が \code{minPts} 以上であればクラスターと認識する計算が実行されます。}
}
\value{
\itemize{
\item cluster: valsに指定したデータ数と対応するクラスタリングの結果ラベルが含まれています。
\item eps1: \code{eps1} 引数の値
\item eps2: \code{eps2} 引数の値
\item minPts: \code{minPts} 引数の値
\item metric: 距離の計算、クラスタリングの条件が含まれています。
\itemize{
\item metric: \code{metric} 引数の値
\item neighbortype: \code{neighbortype} 引数の値
\item dbscantype: \code{dbscantype} 引数の値
}
\item neighborlist: データの隣接点リスト (\code{nb} class) が含まれています。
\item delta_eps: \code{vals} 引数の \code{delta_eps} で指定した値
\item results: クラスタリングの結果が位置情報、時間情報、クラスタリングラベルに分かれて格納されています。
\itemize{
\item geo: 位置情報
\item time: 時間情報
\item value: 位置情報に該当するid, 時間情報, vals引数で指定した各データ値, クラスターラベルがデータフレーム形式で格納されています。\code{neighbortype = "spatial"} の場合は、時間毎に list 化されて格納されています。
}
}
}
\description{
ST-DBSCAN法でクラスタリングを行います。
article{birant2007st,
title={ST-DBSCAN: An algorithm for clustering spatial--temporal data},
author={Birant, Derya and Kut, Alp},
journal={Data \& knowledge engineering},
volume={60},
number={1},
pages={208--221},
year={2007},
publisher={Elsevier}
}
}
\examples{
x <- seq(130, 140, by = 1)
y <- seq(30, 40, by = 1)
t <- as.POSIXct("2024-01-01 00:00:00", tz = "JST") + 3600 * seq(0, 23, by = 6)
geo <- sf::st_as_sf(expand.grid(x, y), coords = c("Var1", "Var2"), crs = 4326)

## for ramdom
D <- abs(runif(nrow(geo))) * 100
clust <- stdbscan(x = cbind(geo, time = rep(t, nrow(geo))[1:nrow(geo)]),
                  eps1 = 144, eps2 = 3600 * 6, minPts = 6,
                  vals = list(list(D = D,
                                   delta_eps = 20)),
                  metric = "geo", neighbortype = "random", dbscantype = "default")

## for spatial
D <- abs(runif(nrow(geo) * length(t))) * 100
clust <- stdbscan(x = geo, time = t, eps1 = 144, eps2 = 3600 * 6, minPts = 6,
                  vals = list(list(D = D,
                                   delta_eps = 20)),
                  metric = "geo", neighbortype = "spatial", dbscantype = "grid")
}
